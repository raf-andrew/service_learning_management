<?php

namespace MCP\Agents\Development\CodeAnalysis;

use MCP\Core\Services\HealthMonitor;
use MCP\Core\Services\AgentLifecycleManager;
use Psr\Log\LoggerInterface;
use PhpParser\ParserFactory;
use PhpParser\NodeTraverser;
use PhpParser\NodeVisitor\NameResolver;
use PhpParser\NodeVisitor\FindingVisitor;

class SecurityVulnerabilityScanningAgent extends BaseCodeAnalysisAgent
{
    private array $metrics = [];
    private array $recommendations = [];
    private array $report = [];
    private array $vulnerabilities = [];
    private array $securityPatterns = [];

    public function __construct(
        HealthMonitor $healthMonitor,
        AgentLifecycleManager $lifecycleManager,
        LoggerInterface $logger
    ) {
        parent::__construct($healthMonitor, $lifecycleManager, $logger);
        
        $this->metrics = [
            'critical_vulnerabilities' => 0,
            'high_vulnerabilities' => 0,
            'medium_vulnerabilities' => 0,
            'low_vulnerabilities' => 0,
            'security_score' => 100
        ];

        $this->initializeSecurityPatterns();
    }

    private function initializeSecurityPatterns(): void
    {
        $this->securityPatterns = [
            'sql_injection' => [
                'pattern' => '/\$.*->query\s*\(\s*\$.*\s*\)/',
                'severity' => 'critical',
                'description' => 'Potential SQL injection vulnerability'
            ],
            'xss' => [
                'pattern' => '/echo\s+.*\$.*/',
                'severity' => 'high',
                'description' => 'Potential XSS vulnerability'
            ],
            'file_inclusion' => [
                'pattern' => '/include\s*\(\s*\$.*\s*\)/',
                'severity' => 'critical',
                'description' => 'Potential file inclusion vulnerability'
            ],
            'command_injection' => [
                'pattern' => '/exec\s*\(\s*\$.*\s*\)/',
                'severity' => 'critical',
                'description' => 'Potential command injection vulnerability'
            ],
            'weak_encryption' => [
                'pattern' => '/md5\s*\(\s*\$.*\s*\)/',
                'severity' => 'medium',
                'description' => 'Use of weak encryption algorithm'
            ]
        ];
    }

    protected function getMetrics(): array
    {
        return $this->metrics;
    }

    public function analyze(array $files): array
    {
        $this->logger->info('Starting security vulnerability analysis');
        
        foreach ($files as $file) {
            if (!file_exists($file)) {
                $this->logger->warning("File not found: {$file}");
                continue;
            }

            $this->analyzeFile($file);
        }

        $this->calculateMetrics();
        $this->generateRecommendations();
        $this->generateReport();

        return $this->report;
    }

    private function analyzeFile(string $file): void
    {
        try {
            $code = file_get_contents($file);
            $parser = (new ParserFactory)->create(ParserFactory::PREFER_PHP7);
            $ast = $parser->parse($code);

            if ($ast === null) {
                $this->logger->warning("Failed to parse file: {$file}");
                return;
            }

            $this->scanForVulnerabilities($code, $file);
            $this->analyzeAst($ast, $file);
        } catch (\Exception $e) {
            $this->logger->error("Error analyzing file {$file}: " . $e->getMessage());
        }
    }

    private function scanForVulnerabilities(string $code, string $file): void
    {
        foreach ($this->securityPatterns as $type => $pattern) {
            if (preg_match($pattern['pattern'], $code)) {
                $this->vulnerabilities[] = [
                    'type' => $type,
                    'severity' => $pattern['severity'],
                    'description' => $pattern['description'],
                    'file' => $file,
                    'line' => $this->findLineNumber($code, $pattern['pattern'])
                ];
            }
        }
    }

    private function analyzeAst(array $ast, string $file): void
    {
        $traverser = new NodeTraverser();
        $visitor = new FindingVisitor(function($node) use ($file) {
            // Implement AST-based vulnerability detection
            return false;
        });
        $traverser->addVisitor($visitor);
        $traverser->traverse($ast);
    }

    private function findLineNumber(string $code, string $pattern): int
    {
        $lines = explode("\n", $code);
        foreach ($lines as $number => $line) {
            if (preg_match($pattern, $line)) {
                return $number + 1;
            }
        }
        return 0;
    }

    private function calculateMetrics(): void
    {
        $this->metrics['critical_vulnerabilities'] = $this->countVulnerabilitiesBySeverity('critical');
        $this->metrics['high_vulnerabilities'] = $this->countVulnerabilitiesBySeverity('high');
        $this->metrics['medium_vulnerabilities'] = $this->countVulnerabilitiesBySeverity('medium');
        $this->metrics['low_vulnerabilities'] = $this->countVulnerabilitiesBySeverity('low');
        $this->metrics['security_score'] = $this->calculateSecurityScore();
    }

    private function countVulnerabilitiesBySeverity(string $severity): int
    {
        return count(array_filter($this->vulnerabilities, function($v) use ($severity) {
            return $v['severity'] === $severity;
        }));
    }

    private function calculateSecurityScore(): int
    {
        $score = 100;
        $score -= $this->metrics['critical_vulnerabilities'] * 20;
        $score -= $this->metrics['high_vulnerabilities'] * 10;
        $score -= $this->metrics['medium_vulnerabilities'] * 5;
        $score -= $this->metrics['low_vulnerabilities'] * 2;
        return max(0, $score);
    }

    public function getRecommendations(): array
    {
        return $this->recommendations;
    }

    private function generateRecommendations(): void
    {
        $this->recommendations = [
            'critical' => $this->generateCriticalRecommendations(),
            'high' => $this->generateHighRecommendations(),
            'medium' => $this->generateMediumRecommendations(),
            'low' => $this->generateLowRecommendations()
        ];
    }

    private function generateCriticalRecommendations(): array
    {
        $recommendations = [];
        if ($this->metrics['critical_vulnerabilities'] > 0) {
            $recommendations[] = "Address critical vulnerabilities immediately";
            $recommendations[] = "Review and fix SQL injection vulnerabilities";
            $recommendations[] = "Review and fix file inclusion vulnerabilities";
            $recommendations[] = "Review and fix command injection vulnerabilities";
        }
        return $recommendations;
    }

    private function generateHighRecommendations(): array
    {
        $recommendations = [];
        if ($this->metrics['high_vulnerabilities'] > 0) {
            $recommendations[] = "Address high severity vulnerabilities";
            $recommendations[] = "Review and fix XSS vulnerabilities";
            $recommendations[] = "Implement proper input validation";
            $recommendations[] = "Use prepared statements for database queries";
        }
        return $recommendations;
    }

    private function generateMediumRecommendations(): array
    {
        $recommendations = [];
        if ($this->metrics['medium_vulnerabilities'] > 0) {
            $recommendations[] = "Address medium severity vulnerabilities";
            $recommendations[] = "Review and update weak encryption algorithms";
            $recommendations[] = "Implement proper error handling";
            $recommendations[] = "Use secure session management";
        }
        return $recommendations;
    }

    private function generateLowRecommendations(): array
    {
        $recommendations = [];
        if ($this->metrics['low_vulnerabilities'] > 0) {
            $recommendations[] = "Address low severity vulnerabilities";
            $recommendations[] = "Review and update deprecated functions";
            $recommendations[] = "Implement proper logging";
            $recommendations[] = "Follow security best practices";
        }
        return $recommendations;
    }

    public function getReport(): array
    {
        return $this->report;
    }

    private function generateReport(): void
    {
        $this->report = [
            'metrics' => $this->metrics,
            'vulnerabilities' => $this->vulnerabilities,
            'recommendations' => $this->recommendations,
            'summary' => $this->generateSummary(),
            'timestamp' => date('Y-m-d H:i:s')
        ];
    }

    private function generateSummary(): array
    {
        return [
            'overall_security_score' => $this->metrics['security_score'],
            'critical_issues' => $this->identifyCriticalIssues(),
            'improvement_areas' => $this->identifyImprovementAreas()
        ];
    }

    private function identifyCriticalIssues(): array
    {
        return array_filter($this->vulnerabilities, function($v) {
            return $v['severity'] === 'critical';
        });
    }

    private function identifyImprovementAreas(): array
    {
        $areas = [];
        if ($this->metrics['security_score'] < 80) {
            $areas[] = "Security score needs improvement";
        }
        if ($this->metrics['critical_vulnerabilities'] > 0) {
            $areas[] = "Critical vulnerabilities need to be addressed";
        }
        if ($this->metrics['high_vulnerabilities'] > 0) {
            $areas[] = "High severity vulnerabilities need to be addressed";
        }
        return $areas;
    }
} 